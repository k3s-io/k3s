package templates

import (
	"strings"
	"testing"

	"github.com/pelletier/go-toml/v2"
	"github.com/k3s-io/k3s/pkg/daemons/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// minimalContainerdConfig returns a config that renders the v3 base template with at least [plugins.'io.containerd.cri.v1.images'].
func minimalContainerdConfig() ContainerdConfig {
	return ContainerdConfig{
		Program: "k3s",
		NodeConfig: &config.Node{
			Containerd: config.Containerd{
				Address:  "/run/k3s/containerd/containerd.sock",
				Root:     "/var/lib/rancher/k3s/agent/containerd",
				Opt:      "/var/lib/rancher/k3s/agent/containerd",
				State:    "/run/k3s/containerd",
				Registry: "/var/lib/rancher/k3s/agent/etc/containerd/certs.d",
			},
			AgentConfig: config.Agent{
				Snapshotter: "overlayfs",
			},
		},
		SystemdCgroup: true,
	}
}

func TestParseTemplateFromConfig_BaseOnly(t *testing.T) {
	cfg := minimalContainerdConfig()
	userTemplate := `{{ template "base" . }}`
	got, err := ParseTemplateFromConfig(userTemplate, ContainerdConfigTemplateV3, cfg)
	require.NoError(t, err)
	assert.Contains(t, got, "# File generated by k3s.")
	assert.Contains(t, got, "version = 3")
	assert.Contains(t, got, "[plugins.")
	assert.Contains(t, got, "io.containerd.cri.v1.images")
	// No duplicate table for the same section (key may be quoted with ' or ")
	assert.LessOrEqual(t, 1, strings.Count(got, "io.containerd.cri.v1.images"), "expected at most one plugins.cri.v1.images section in output")
}

func TestParseTemplateFromConfig_MergeOverlappingSection(t *testing.T) {
	// User adds/overrides [plugins."io.containerd.cri.v1.images"] (same as base) - must merge, not duplicate (issue 13678).
	cfg := minimalContainerdConfig()
	userTemplate := `{{ template "base" . }}

[plugins."io.containerd.cri.v1.images"]
disable_snapshot_annotations = false

[plugins."io.containerd.cri.v1.images".runtime_platforms.kata]
snapshotter = "nydus"
`
	got, err := ParseTemplateFromConfig(userTemplate, ContainerdConfigTemplateV3, cfg)
	require.NoError(t, err)
	assert.Contains(t, got, "disable_snapshot_annotations = false", "user override must win")
	assert.Contains(t, got, "runtime_platforms")
	assert.Contains(t, got, "nydus", "runtime_platforms.kata snapshotter")
	// Merged output must be valid TOML with a single plugins.cri.v1.images section
	body := got
	if idx := strings.Index(got, "\n"); idx >= 0 && strings.HasPrefix(strings.TrimSpace(got), "#") {
		body = got[idx+1:]
	}
	var m map[string]interface{}
	require.NoError(t, toml.Unmarshal([]byte(body), &m))
	plugins, _ := m["plugins"].(map[string]interface{})
	require.NotNil(t, plugins)
	images, _ := plugins["io.containerd.cri.v1.images"].(map[string]interface{})
	require.NotNil(t, images, "merged config must have plugins.io.containerd.cri.v1.images")
	assert.Equal(t, false, images["disable_snapshot_annotations"], "user override disable_snapshot_annotations = false")
	runtimePlatforms, _ := images["runtime_platforms"].(map[string]interface{})
	require.NotNil(t, runtimePlatforms)
	kata, _ := runtimePlatforms["kata"].(map[string]interface{})
	require.NotNil(t, kata)
	assert.Equal(t, "nydus", kata["snapshotter"])
}

func TestParseTemplateFromConfig_MergeIsValidTOML(t *testing.T) {
	cfg := minimalContainerdConfig()
	userTemplate := `{{ template "base" . }}

[plugins."io.containerd.cri.v1.images"]
disable_snapshot_annotations = false

[plugins."io.containerd.cri.v1.runtime".containerd.runtimes.kata-qemu]
runtime_type = "io.containerd.kata.v2"
`
	got, err := ParseTemplateFromConfig(userTemplate, ContainerdConfigTemplateV3, cfg)
	require.NoError(t, err)
	// Re-parse to ensure output is valid TOML
	var m map[string]interface{}
	// Strip header comment for parsing
	body := got
	if idx := strings.Index(got, "\n"); idx >= 0 && strings.HasPrefix(strings.TrimSpace(got), "#") {
		body = got[idx+1:]
	}
	err = toml.Unmarshal([]byte(body), &m)
	require.NoError(t, err, "merged output must be valid TOML")
	assert.NotEmpty(t, m["plugins"])
}

func TestParseTemplateFromConfig_UserAdditionsOnly(t *testing.T) {
	// User template that does not call base: only user content is merged on top of base (so base + user).
	cfg := minimalContainerdConfig()
	userTemplate := `[debug]
level = "debug"
`
	got, err := ParseTemplateFromConfig(userTemplate, ContainerdConfigTemplateV3, cfg)
	require.NoError(t, err)
	// Base is still present (we merge base + user)
	assert.Contains(t, got, "version = 3")
	assert.Contains(t, got, "[debug]")
	assert.Contains(t, got, "level", "user [debug] section must be present")
}
